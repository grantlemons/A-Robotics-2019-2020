package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.util.Range;

@TeleOp(name="Full Build", group="Linear Opmode")

public class FullBuild extends LinearOpMode {

    // Declare OpMode members.
    private ElapsedTime runtime = new ElapsedTime();
    private DcMotor leftFront = null;
    private DcMotor leftBack = null;
    private DcMotor rightFront = null;
    private DcMotor rightBack = null;
    
    //Define Hardware
    public void hardwareInit() {
        //Hardware Map
        leftFront  = hardwareMap.get(DcMotor.class, "leftfront");
        rightFront = hardwareMap.get(DcMotor.class, "rightfront");
        leftBack = hardwareMap.get(DcMotor.class, "leftback");
        rightBack = hardwareMap.get(DcMotor.class, "rightback");
        //Direction Setting
        leftFront.setDirection(DcMotor.Direction.REVERSE);
        rightFront.setDirection(DcMotor.Direction.FORWARD);
        leftBack.setDirection(DcMotor.Direction.REVERSE);
        rightBack.setDirection(DcMotor.Direction.FORWARD);
    }
    
    //Turn until degrees is ~0
    public void findZero(double degrees) {
        double AutoPower = degrees*0.05;
        if (degrees >= 5) {
            //TURN RIGHT
            leftFront.setPower(AutoPower);
            rightFront.setPower(-AutoPower);
            leftBack.setPower(AutoPower);
            rightBack.setPower(-AutoPower);
        } else if (degrees <= -4) {
            //TURN LEFT
            leftFront.setPower(-AutoPower);
            rightFront.setPower(AutoPower);
            leftBack.setPower(-AutoPower);
            rightBack.setPower(AutoPower);
        }
    }
    //Run Opmode
    @Override
    public void runOpMode() {
        hardwareInit();
        telemetry.addData("Status", "Initialized");
        telemetry.update();
        waitForStart();
        runtime.reset();
        //Self-rights when y is pressed on controller 1
        //NEEDS GYRO INTEGRATION ASAP
        while (opModeIsActive()) {
            //Self right when y is pressed
            while (gamepad1.y = 1)
                findZero(Orientation.firstAngle);
            driving();
            telemetry();
        }
    }
    public void telemetry() {
        // Show the elapsed game time and wheel power.
        telemetry.addData("Status", "Run Time: " + runtime.toString());
        telemetry.addData("Motors", "LF (%.2f), RF (%.2f), LB (%.2f), RB (%.2f)", leftFrontPowerCalculated, rightFrontPowerCalculated, leftBackPowerCalculated, rightBackPowerCalculated);
        telemetry.addData("Heading", "Heading: (%.2f)", Orientation.firstAngle);
        telemetry.update();
    }
    public void driving() {
        // Setup a variable for each drive wheel to save power level for telemetry
        double leftFrontPower;
        double rightFrontPower;
        double leftBackPower;
        double rightBackPower;
        //Inputs
        double drive = -gamepad1.left_stick_y;
        double strafe  = gamepad1.left_stick_x;
        double turn = gamepad1.right_stick_x;
        double leftPower    = Range.clip(drive, 1.0);
        double rightPower   = Range.clip(drive, 1.0);
        //Turning
        if(turn >= 3) {
            double leftPowerTurn = leftPower - turn * 0.25;
            double rightPowerTurn = rightPower + turn * 0.25;
        } else if (turn <= -3) {
            double leftPowerTurn = leftPower + turn * 0.25;
            double rightPowerTurn = rightPower - turn * 0.25;
        }
        //If strafe stick is positive
        if(strafe>=0) {
            leftFrontPower   = Range.clip(strafe, 1.0);
            rightFrontPower  = Range.clip(strafe, -1.0);
            leftBackPower  = Range.clip(strafe, -1.0);
            rightBackPower = Range.clip(strafe, 1.0);
        }
        //If stick is negative
        else {
            leftFrontPower   = Range.clip(strafe, -1.0);
            rightFrontPower  = Range.clip(strafe, 1.0);
            leftBackPower  = Range.clip(strafe, 1.0);
            rightBackPower = Range.clip(strafe, -1.0);
        }
        //Add together individual with totals
        double leftFrontPowerCalculated = leftPowerTurn + leftFrontPower;
        double rightFrontPowerCalculated = rightPowerTurn + rightFrontPower;
        double leftBackPowerCalculated = leftPowerTurn + leftBackPower;
        double rightBackPowerCalculated = rightPowerTurn + rightBackPower;
        double leftPowerCalculated = leftBackPowerCalculated + leftFrontPowerCalculated;
        double rightPowerCalculated = leftBackPowerCalculated + leftFrontPowerCalculated;

        // Send calculated power to wheels
        leftFront.setPower(leftFrontPowerCalculated);
        rightFront.setPower(rightFrontPowerCalculated);
        leftBack.setPower(leftBackPowerCalculated);
        rightBack.setPower(rightBackPowerCalculated);
    }
}
